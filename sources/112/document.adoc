= MN 112: Auto-numbering Definition Language (ANDL) specification
:docnumber: 112
:edition: 1
:revdate: 2025-02-28
:copyright-year: 2025
:language: en
:title-main-en: Auto-numbering Definition Language (ANDL) specification
:doctype: standard
:status: draft
:mn-document-class: ribose
:mn-output-extensions: xml,html,pdf,rxl
:local-cache-only:

[[introduction]]
== Introduction

This specification defines the Auto-numbering Definition Language (ANDL), a
declarative modeling language for defining automatic numbering requirements
across technical documentation and publishing systems.

Auto-numbering is a critical component of structured documentation, enabling
consistent referencing and organization of content elements throughout a document.
However, implementing auto-numbering consistently across multiple output formats
(HTML, PDF, Word) presents significant challenges in maintaining both visual
consistency and semantic meaning.

ANDL addresses these challenges by providing:

. A platform-independent numbering model that works consistently across rendering engines
. Built-in support for international numbering systems (including CJK)
. Hierarchical numbering with contextual awareness and scope binding
. Clear separation between semantic structure and presentation formatting
. Support for transformations to CSS, Word Styles, and XSLT counters
. String pattern interpolation for flexible label construction

ANDL enables document architects and standards developers to define once and apply
everywhere, ensuring that numbering schemes work predictably across all outputs
while preserving both semantic structure and visual presentation requirements.

[[scope]]
== Scope

This document establishes requirements for defining auto-numbering schemes for:

* Ordered and unordered list items with multiple nesting levels
* Document structural elements (clauses, annexes, appendices)
* Figures, tables, examples, and notes
* Source code blocks and requirement statements
* CJK and other international numbering systems
* Hierarchical numbering relationships
* Advanced string pattern interpolation
* Counter scope binding based on document context

This specification defines the conceptual models for auto-numbering and their
transformation to implementation formats including CSS counters, Word Styles,
and XSLT counter variables.

[[terms-and-definitions]]
== Terms and definitions

=== counter

numeric or alphanumeric variable that tracks sequence position within a document context

=== sequence

ordered progression of values following defined rules for generation and formatting

=== numbering format

rules for representing a counter value in a particular alphanumeric system

[example]
====
Arabic numerals, Roman numerals, alphabetic characters.
====

=== numbering pattern

template combining counter values and literal characters to form complete labels

[example]
====
"Figure %n" is a pattern that generates labels like "Figure 1", "Figure 2", etc.
====

=== hierarchical numbering

numbering system where elements inherit context from parent elements

[example]
====
In a numbering system, "1.1.2" can represent the locality of "section 1,
subsection 1, clause 2".
====

=== counter scope

document boundary within which a counter operates, defining when the counter resets or continues

=== string interpolation

process of substituting variable placeholders in a pattern with actual values to construct a label

[[requirements]]
== Requirements

=== Problem statement

Information management systems must produce consistent, predictable
auto-numbering across multiple output formats while:

* Preserving semantic relationships between numbered elements
* Adapting to different display requirements by format
* Supporting internationalization requirements
* Allowing for hierarchical numbering schemes
* Enabling flexible formatting of labels
* Managing counter scopes across document boundaries

=== Usage in Metanorma

Metanorma XML uses ANDL to define auto-numbering for elements that require
sequence tracking. These definitions are interpreted by end-format renderers to generate
appropriate numbering in the target format. The model must provide:

* Common patterns applicable across formats
* Format-specific transformation instructions
* Separation of semantic numbering (what something is) from presentation (how it appears)
* Support for complex numbering schemes required by standards organizations

[[principles]]
== Principles

=== Separation of concerns

ANDL follows these fundamental design principles:

. *Separation of semantics and presentation*: Numbers represent both position in a sequence and
  visual labeling. These concerns must be separable for proper processing.

. *Context awareness*: Numbering systems must understand their position within document hierarchies.

. *Independence from format*: The model must define numbering in a way that can be consistently
  applied across HTML, PDF, Word, and other formats.

. *Transformation clarity*: Format-specific renderings must be clearly derivable from the base model.

. *Internationalization support*: Non-Latin numbering systems must be fully supported.

=== Model architecture

The ANDL model architecture consists of:

* Core models defining counters, sequences, and formats
* Element-specific extensions for particular document components
* Transformation templates for output formats
* Hierarchical context management
* Scope binding framework
* Pattern interpolation system

[[core-models]]
== Core models

=== Counter relationships diagram

The following diagrams illustrate the key relationships in the ANDL counter model:

[source,ascii]
----
                  Counter Model Relationships
                  ==========================

+----------------+         +-------------------+
|    Counter     |         |  NumberSequence   |
|----------------|-------->|-------------------|
| id             |         | initial_value     |
| current_value  |         | increment         |
| sequence       |         | cycle_length      |
+----------------+         +-------------------+
        |
        |                  +-------------------+
        +----------------->| CharacterSequence |
                           |-------------------|
                           | type (alpha/roman)|
                           | case              |
                           | characters        |
                           +-------------------+

                   Scope and Element Binding
                   =======================

+----------------+         +----------------+
|    Counter     |<------->|     Scope      |
|----------------|         |----------------|
| id             |         | context        |
| sequence       |         | boundary       |
+----------------+         +----------------+
        |
        |                  +----------------+
        +----------------->|  ElementType   |
                           |----------------|
                           | name           |
                           | attributes     |
                           +----------------+

                 Hierarchical Counter Example
                 =========================

+-------------------+         +-------------------+
| Parent Counter    |         | Child Counter     |
|-------------------|<--------|-------------------|
| id: "section"     |         | id: "figure"      |
| sequence: 1,2,3.. |         | sequence: 1,2,3.. |
| scope: document   |         | scope: section    |
+-------------------+         +-------------------+
                                       |
                                       v
                              +-------------------+
                              | NumberingPattern  |
                              |-------------------|
                              | "%parent.%n"      |
                              | -> "1.1", "1.2"   |
                              +-------------------+

                 "Figure A.1" Construction
                 =======================

+-------------------+         +-------------------+
| Annex Counter     |         | Figure Counter    |
|-------------------|<--------|-------------------|
| id: "annex"       |         | id: "figure"      |
| sequence: A,B,C.. |         | sequence: 1,2,3.. |
| scope: document   |         | scope: annex      |
+-------------------+         +-------------------+
        |                               |
        v                               v
+-------------------+         +-------------------+
| Output: "A"       |         | Output: "1"       |
+-------------------+         +-------------------+
        |                               |
        |                               |
        v                               v
        +---------------+---------------+
                        |
                        v
                +-------------------+
                | Combined Pattern  |
                |-------------------|
                | "Figure %parent.%n"|
                | -> "Figure A.1"   |
                +-------------------+
----

=== Sequence

A sequence defines the progression of values for a counter.

There are two types of Sequence models that inherit from Sequence:

* CharacterSequence
* NumberSequence

[source,lml]
----
class Sequence {
  method value_for_order(order: Integer) {
    definition "Provide the value for a given order in the sequence"
  }

  method set_initial_value(order: Integer) {
    definition "Set the sequence to start at a specific value"
  }
}
----

[source,lml]
----
class NumberSequence < Sequence {
  attribute initial_value, Integer {
    definition "Starting value for the sequence"
    default: 1
  }
  attribute increment, Integer {
    definition "Value to increment by for each step"
    default: 1
  }
  attribute cycle_length, Integer {
    definition "Length after which sequence notation expands"
  }
  attribute base_sequence, Sequence {
    definition "Base sequence that this sequence builds upon"
  }
}
----

An ANDL-compliant runtime should provide the following default
numbering sequences:

`DecimalNumberSequence`:: Standard decimal numbers (1, 2, 3...)
`RomanUpperNumberSequence`:: Uppercase Roman numerals (I, II, III...)
`RomanLowerNumberSequence`:: Lowercase Roman numerals (i, ii, iii...)
`AlphaUpperNumberSequence`:: Uppercase letters (A, B, C...)
`AlphaLowerNumberSequence`:: Lowercase letters (a, b, c...)
`CyrillicUpperCharacterSequence`:: Uppercase Cyrillic alphabet characters (А, Б, В, Г, Д, Е, Ж, З...)
`CyrillicLowerCharacterSequence`:: Lowercase Cyrillic alphabet characters (а, б, в, г, д, е, ж, з...)
`GreekUpperCharacterSequence`:: Uppercase Greek alphabet characters (Α, Β, Γ, Δ, Ε, Ζ, Η, Θ...)
`GreekLowerCharacterSequence`:: Lowercase Greek alphabet characters (α, β, γ, δ, ε, ζ, η, θ...)
`ChineseNumberSequence`:: Chinese numerals (一, 二, 三...)
`JapaneseNumberSequence`:: Japanese numerals (一, 二, 三...)
`KoreanNumberSequence`:: Korean numerals (일, 이, 삼...)
`ArabicNumberSequence`:: Arabic numerals in Arabic script (١, ٢, ٣...)

[example]
====
Instance definition of custom numeral sequence based on ArabicNumberSequence
that jumps every 3:

[source,lml]
----
instance ThreeIncrementArabicNumberSequence {
  base_sequence = ArabicNumberSequence
  initial_value = 1
  increment = 3
}
----

Produces a sequence of "1, 4, 7, 10, ...".
====

[example]
====
Instance definition of a custom numeral sequence based on Chinese numeral
sequence only gives even numbers:

[source,lml]
----
instance EvenChineseNumberSequence {
  base_sequence = ChineseNumberSequence
  initial_value = 2
  increment = 2
}
----

Produces a sequence of "二, 四, 六, 八, ...".
====


[source,lml]
----
class CharacterSequence < Sequence {
  attribute characters, String {
    definition "Strings that define a label for an ordered element in the sequence"
    cardinality 1..n
  }
  attribute expansion_rule, String {
    definition "Rule for expanding sequence after completion"
    values {
      value "repeat_label" {
        definition "Repeat the label character"
      }
      value "prepend_prefix" {
        definition "Add a new prefix character"
      }
      value "double_character" {
        definition "Double the character for expansion"
      }
      value "none" {
        definition "No expansion applied"
      }
      value "append_suffix" {
        definition "Append a suffix character after expansion"
      }
    }
  }
}
----

[example]
====
Certain ancient texts apply the numbering system of ["乾", "亨", "利", "貞"] as
book labels if there are 4 books in a series. The following definition applies
the expansion rule "prepend_prefix" to the sequence.

[source,lml]
----
instance YiJingCharacterSequence {
  characters = ["乾", "亨", "利", "貞"]
  expansion_rule = "prepend_prefix"
  expansion_prefix = ["乾", "坤", "巽", "震", "坎", "艮", "離", "兌"]
}
----

Produces a sequence of "乾, 亨, 利, 貞, 乾乾, 乾亨, 乾利, 乾貞, 亨乾, 亨亨, ...".
====

[example]
====
Greek literature uses the Greek alphabet and numerals for numbering, which
includes both letters and specific numeral characters for enumeration. The
following definition applies the expansion rule "double_character" to the
sequence.

[source,lml]
----
instance GreekCharacterSequence {
  characters = ["α", "β", "γ", "δ", "ε", "ζ", "η", "θ"]
  expansion_rule = "double_character"
}
----

Produces a sequence of "α, β, γ, δ, ε, ζ, η, θ, αα, ββ, γγ, δδ, ...".
====

=== Counter

The Counter model defines the fundamental mechanism for tracking sequence
position within a context.

[source,lml]
----
class Counter {
  attribute sequence, Sequence {
    definition "Sequence that defines the counter's possible values"
  }
  attribute context, Context {
    definition "Context to which this counter is bound"
  }
  attribute parent_counter, ref:(Counter) {
    definition "Parent counter to which this counter relies upon"
  }
}
----

=== Context

The Context class is responsible for defining the scope of counters within a
document. This includes both the element that establishes the scope and the type
of the scope.

----
class Context {
  attribute counters, ref:(Counter) {
    definition "All counters (of different types) that are bound to this context"
    collection true
  }

  attribute type, String {
    definition {
      Type of context element that defines this counter's scope.

      Values are free form, such as:

      * "document"
      * "section"
      * "container"
      * "clause"
      * "annex"
    }
  }

  method value_for_order_and_type(order: Integer, type: String) {
    definition "Provide the value for a given order in the sequence"
  }
}
----

[example]
====
Simple counter for tracking Notes:

[source,lml]
----
instance SectionContext {
  type = "section"
  counters = ["id:notes_counter"]
}

instance NotesCounter {
  id = "notes_counter"
  sequence = ArabicNumberSequence
}
----

The values would be:
----
> SectionContext.value_for_order_and_type(1, "note") => 1
> SectionContext.value_for_order_and_type(2, "note") => 2
> SectionContext.value_for_order_and_type(3, "note") => 3
----
====

[example]
====
Simple counter for tracking Figures:

[source,lml]
----
instance SectionContext {
  type = "section"
  counters = ["id:figure_counter"]
}

instance FigureCounter {
  id = "figure_counter"
  sequence = RomanUpperNumberSequence
}
----

The values would be:
----
> SectionContext.value_for_order_and_type(1, "figure") => I
> SectionContext.value_for_order_and_type(2, "figure") => II
> SectionContext.value_for_order_and_type(3, "figure") => III
----
====

=== Label pattern

The LabelPattern class defines how counter values are combined with fixed text
to create labels.

A string pattern with placeholders for counter values is used to generate the
visible label.

[source,lml]
----
class LabelPattern {
  attribute pattern, String {
    definition "Template string with placeholders for counter values"
  }
  attribute counter, Counter {
    definition "Counter driving the pattern"
  }
}
----

Interpolation patterns:

`%n`:: Counter value
`%parent`:: Parent counter value

[example]
====
Simple figure labeling pattern:

[source]
----
Figure %n
----

[source,lml]
----
instance FigureLabelPattern {
  pattern = "Figure %n"
}
----

Output: "Figure 1", "Figure 2", "Figure 3", etc.
====


=== Label renderer

The LabelRenderer class is responsible for transforming a label pattern into a
final label string.

[source,lml]
----
class LabelRenderer {
  attribute counter, Counter {
    definition "Counter driving the label"
  }
  attribute pattern, LabelPattern {
    definition "Pattern for generating the label"
  }

  method render_label(sequence: Integer) {
    definition "Render a label based on the counter and pattern"
  }
}
----

[example]
====
Rendering a label for a figure:

[source,lml]
----
instance FigureCounter {
  id = "figure_counter"
  sequence = ArabicNumberSequence
}

instance FigureLabelPattern {
  id = "figure_label_pattern"
  pattern = "Figure %n"
}

instance FigureLabelRenderer {
  counter = "figure_counter"
  pattern = "figure_label_pattern"
}
----

----
FigureLabelRenderer.render_label(3) => "Figure 3"
----
====

[example]
.Example with hierarchical numbering of clauses
====
Hierarchical numbering of clauses:

[source,lml]
----
instance ClauseNumberSequence < NumberSequence {
  initial_value = 1
  format = "arabic"
}

instance DocumentContext < Context {
  type = "document"
}

instance ClauseCounter < Counter {
  id = "clause_counter"
  sequence = ClauseNumberSequence
  scope = DocumentContext
}

instance ClauseLabelRenderer < LabelRenderer {
  counter = ClauseCounter
  pattern = instance ClauseLabelPattern < LabelPattern {
    pattern = "Clause %n"
  }
}
# ClauseLabelRenderer.render_label(1) => "Clause 1"
# ClauseLabelRenderer.render_label(3) => "Clause 3"

instance ClauseLabelRendererForSubclause < LabelRenderer {
  counter = ClauseCounter
  pattern = instance ClauseLabelPattern < LabelPattern {
    pattern = "%n"
  }
}
# ClauseLabelRendererForSubclause.render_label(1) => "1"
# ClauseLabelRendererForSubclause.render_label(3) => "3"

instance ClauseContext < Context {
  type = "clause"
}

instance SubClauseCounter < Counter {
  id = "subclause_counter"
  sequence = ClauseNumberSequence
  scope = ClauseContext
  parent_counter = ClauseLabelRendererForSubclause
}

instance SubClauseLabelRenderer < LabelRenderer {
  counter = SubClauseCounter
  pattern = instance SubClauseLabelPattern < LabelPattern {
    pattern = "%parent.%n"
  }
}
# SubClauseLabelRenderer.render_label(1) => "1.1"
# SubClauseLabelRenderer.render_label(3) => "1.3"
----
====

=== Presentation and semantics model

The Presentation and Semantics model separates meaning from display.

[source,lml]
----
class NumberedElement {
  attribute element_type, String {
    definition "Type of document element being numbered"
  }
  attribute semantic_info, SemanticInfo {
    definition "Semantic information about the numbered element"
  }
  attribute presentation_info, PresentationInfo {
    definition "Information about how the element should be presented"
  }
}

class SemanticInfo {
  attribute counters, Array {
    definition "Counters used to track this element"
    cardinality 1..n
  }
  attribute structure_level, Integer {
    definition "Level in document structure hierarchy"
  }
  attribute context_path, String {
    definition "XPath-like path to locate element in document structure"
  }
}

class PresentationInfo {
  attribute label_pattern, NumberingPattern {
    definition "Pattern for generating the visible label"
  }
  attribute format_overrides, Hash {
    definition "Format-specific overrides"
  }
  attribute style_properties, Hash {
    definition "CSS and other style properties"
  }
}
----

[example]
====
Separation of semantics and presentation for a figure:

[source,lml]
----
instance NumberedElement {
  element_type = "figure"
  semantic_info = instance SemanticInfo {
    counters = ["figure_counter"]
    structure_level = 1
    context_path = "/document/sections/section[id='section-3']/figure[1]"
  }
  presentation_info = instance PresentationInfo {
    label_pattern = instance NumberingPattern {
      pattern = "Figure %n —"
      counter_references = ["figure_counter"]
    }
  }
}
----

This separates the semantic information (it's the first figure in section 3) from the presentation (it should be labeled as "Figure 1 —").
====

[[auto-numbered-items]]
== Auto-numbered items

=== List numbering

Lists are among the most commonly numbered elements in documents, with both ordered and unordered variants.

==== Ordered lists

Ordered lists use sequential counters with various numbering formats and nested hierarchies.

[source,lml]
----
class OrderedListNumbering {
  attribute counter, Counter {
    definition "Counter tracking list item position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for list item labels"
  }
  attribute level_formats, Array {
    definition "Formats to use at different nesting levels"
    cardinality 0..n
  }
}

class OrderedListLevelFormat {
  attribute level, Integer {
    definition "Nesting level (1 = top level)"
  }
  attribute format, SequenceFormat {
    definition "Numbering format for this level"
  }
  attribute pattern, String {
    definition "Label pattern for this level"
  }
}
----

[example]
====
Basic ordered list:

[source,lml]
----
instance OrderedListNumbering {
  counter = instance Counter {
    id = "ordered_list_items"
    sequence = instance NumberSequence {
      initial_value = 1
      format = "arabic"
    }
    scope = instance Context {
      context_element = "list"
      scope_type = "container"
    }
  }
  pattern = instance NumberingPattern {
    pattern = "%n. "
  }
}
----

Output: "1. ", "2. ", "3. "
====

[example]
====
Nested ordered list with different formats:

[source,lml]
----
instance OrderedListNumbering {
  level_formats = [
    instance OrderedListLevelFormat {
      level = 1
      format = "arabic"
      pattern = "%n. "
    },
    instance OrderedListLevelFormat {
      level = 2
      format = "alpha_lower"
      pattern = "%n) "
    },
    instance OrderedListLevelFormat {
      level = 3
      format = "roman_lower"
      pattern = "(%n) "
    }
  ]
}
----

Output for first level: "1. ", "2. ", "3. "
Output for second level: "a) ", "b) ", "c) "
Output for third level: "(i) ", "(ii) ", "(iii) "
====

==== Unordered lists

Unordered lists use non-sequential markers for visual distinction.

[source,lml]
----
class UnorderedListMarkers {
  attribute level_markers, Array {
    definition "Markers to use at different nesting levels"
    cardinality 1..n
  }
}

class UnorderedListLevelMarker {
  attribute level, Integer {
    definition "Nesting level (1 = top level)"
  }
  attribute marker, String {
    definition "Symbol to use for this level"
  }
}
----

[example]
====
Unordered list with custom markers:

[source,lml]
----
instance UnorderedListMarkers {
  level_markers = [
    instance UnorderedListLevelMarker {
      level = 1
      marker = "•"
    },
    instance UnorderedListLevelMarker {
      level = 2
      marker = "◦"
    },
    instance UnorderedListLevelMarker {
      level = 3
      marker = "▪"
    }
  ]
}
----

Output for first level: "• Item"
Output for second level: "◦ Item"
Output for third level: "▪ Item"
====

=== Clause numbering

Clauses form the primary structural elements of technical documents and use hierarchical numbering.

[source,lml]
----
class ClauseNumbering {
  attribute counter, Counter {
    definition "Counter tracking clause position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for clause labels"
  }
  attribute max_depth, Integer {
    definition "Maximum depth to display in numbering"
    default: 6
  }
}
----

[example]
====
Clause numbering with hierarchical structure:

[source,lml]
----
// Section counter
instance Counter {
  id = "section_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

// Subsection counter
instance Counter {
  id = "subsection_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "section"
    scope_type = "section"
  }
  parent_counter = "section_counter"
}

// Subsubsection counter
instance Counter {
  id = "subsubsection_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "subsection"
    scope_type = "section"
  }
  parent_counter = "subsection_counter"
}

// Patterns for each level
instance NumberingPattern {
  pattern = "%n"
  counter_references = ["section_counter"]
}

instance NumberingPattern {
  pattern = "%parent.%n"
  counter_references = ["subsection_counter", "section_counter"]
}

instance NumberingPattern {
  pattern = "%parent.%n"
  counter_references = ["subsubsection_counter", "subsection_counter"]
}
----

Output for section: "1", "2", "3"
Output for subsection: "1.1", "1.2", "2.1"
Output for subsubsection: "1.1.1", "1.1.2", "1.2.1"
====

=== Annex and appendix numbering

Annexes and appendices typically use different numbering schemes than the main document.

[source,lml]
----
class AnnexNumbering {
  attribute counter, Counter {
    definition "Counter for tracking annex position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for annex labels"
  }
  attribute prefix, String {
    definition "Text to prefix annex number with"
    default: "Annex "
  }
}
----

[example]
====
Annex numbering:

[source,lml]
----
instance Counter {
  id = "annex_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "alpha_upper"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "Annex %n"
  counter_references = ["annex_counter"]
}
----

Output: "Annex A", "Annex B", "Annex C"
====

[example]
====
Hierarchical annex with appendix:

[source,lml]
----
instance Counter {
  id = "annex_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "alpha_upper"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance Counter {
  id = "appendix_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "annex"
    scope_type = "section"
  }
  parent_counter = "annex_counter"
}

instance NumberingPattern {
  pattern = "Annex %n"
  counter_references = ["annex_counter"]
}

instance NumberingPattern {
  pattern = "Appendix %n"
  counter_references = ["appendix_counter"]
}
----

Output for annex: "Annex A", "Annex B"
Output for appendix within annex: "Appendix 1", "Appendix 2"
====

=== Figure numbering

Figures typically use a combination of sequential and hierarchical numbering.

[source,lml]
----
class FigureNumbering {
  attribute counter, Counter {
    definition "Counter for tracking figure position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for figure labels"
  }
  attribute caption_location, String {
    definition "Where to place the caption"
    values { "before", "after" }
    default: "after"
  }
}
----

[example]
====
Document-wide sequential figure numbering:

[source,lml]
----
instance Counter {
  id = "figure_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "Figure %n —"
  counter_references = ["figure_counter"]
}
----

Output: "Figure 1 —", "Figure 2 —", "Figure 3 —"
====

[example]
====
Hierarchical figure numbering by section:

[source,lml]
----
instance Counter {
  id = "figure_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "section"
    scope_type = "section"
  }
  parent_counter = "section_counter"
}

instance NumberingPattern {
  pattern = "Figure %parent.%n —"
  counter_references = ["figure_counter", "section_counter"]
}
----

Output: "Figure 1.1 —", "Figure 1.2 —", "Figure 2.1 —"
====

[example]
====
Figure in an annex:

[source,lml]
----
instance Counter {
  id = "figure_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "annex"
    scope_type = "section"
  }
  parent_counter = "annex_counter"
}

instance NumberingPattern {
  pattern = "Figure %parent.%n —"
  counter_references = ["figure_counter", "annex_counter"]
}
----

Output: "Figure A.1 —", "Figure A.2 —", "Figure B.1 —"
====

=== Table numbering

Tables use numbering schemes similar to figures but often with different presentation.

[source,lml]
----
class TableNumbering {
  attribute counter, Counter {
    definition "Counter for tracking table position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for table labels"
  }
  attribute caption_location, String {
    definition "Where to place the caption"
    values { "before", "after" }
    default: "before"
  }
}
----

[example]
====
Document-wide sequential table numbering:

[source,lml]
----
instance Counter {
  id = "table_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "Table %n —"
  counter_references = ["table_counter"]
}
----

Output: "Table 1 —", "Table 2 —", "Table 3 —"
====

=== Note numbering

Notes may appear throughout a document and are typically numbered within their context.

[source,lml]
----
class NoteNumbering {
  attribute counter, Counter {
    definition "Counter for tracking note position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for note labels"
  }
  attribute note_type, String {
    definition "Type of note"
    values { "note", "warning", "tip", "important", "caution" }
    default: "note"
  }
}
----

[example]
====
Notes numbered per clause:

[source,lml]
----
instance Counter {
  id = "note_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "clause"
    scope_type = "section"
  }
}

instance NumberingPattern {
  pattern = "NOTE %n:"
  counter_references = ["note_counter"]
}
----

Output within a clause: "NOTE 1:", "NOTE 2:", "NOTE 3:"
When a new clause begins, numbering restarts.
====

=== Example numbering

Examples often follow similar numbering patterns to notes.

[source,lml]
----
class ExampleNumbering {
  attribute counter, Counter {
    definition "Counter for tracking example position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for example labels"
  }
}
----

[example]
====
Examples numbered per document:

[source,lml]
----
instance Counter {
  id = "example_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "EXAMPLE %n:"
  counter_references = ["example_counter"]
}
----

Output: "EXAMPLE 1:", "EXAMPLE 2:", "EXAMPLE 3:"
====

=== Source code numbering

Source code blocks may be numbered for reference.

[source,lml]
----
class SourceCodeNumbering {
  attribute counter, Counter {
    definition "Counter for tracking source code block position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for source code labels"
  }
  attribute caption_location, String {
    definition "Where to place the caption"
    values { "before", "after" }
    default: "before"
  }
  attribute line_numbers, Boolean {
    definition "Whether to include line numbers"
    default: false
  }
}
----

[example]
====
Source code blocks with captions:

[source,lml]
----
instance Counter {
  id = "sourcecode_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "Listing %n —"
  counter_references = ["sourcecode_counter"]
}
----

Output: "Listing 1 — Example function", "Listing 2 — Another function"
====

=== Requirement numbering

Requirements often need special numbering for traceability.

[source,lml]
----
class RequirementNumbering {
  attribute counter, Counter {
    definition "Counter for tracking requirement position"
  }
  attribute prefix, String {
    definition "Prefix for requirement ID"
    default: "REQ-"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for requirement labels"
  }
}
----

[example]
====
Hierarchical requirement numbering:

[source,lml]
----
instance Counter {
  id = "requirement_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "section"
    scope_type = "section"
  }
  parent_counter = "section_counter"
}

instance NumberingPattern {
  pattern = "REQ-%parent.%n"
  counter_references = ["requirement_counter", "section_counter"]
}
----

Output: "REQ-1.1", "REQ-1.2", "REQ-2.1"
====

=== CJK numbering support

The CJK numbering model provides support for Chinese, Japanese, and Korean numbering systems.

[source,lml]
----
class CJKNumbering {
  attribute language, String {
    values { "zh", "ja", "ko" }
    definition "Language code determining the numbering system"
  }
  attribute format_type, String {
    values { "financial", "formal", "informal", "simplified" }
    definition "Style of CJK numerals to use"
    default: "formal"
  }
  attribute counter_reference, String {
    definition "Reference to the base counter to convert"
  }
}
----

[example]
====
Chinese formal numbering:

[source,lml]
----
instance Counter {
  id = "section_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "chinese"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "第%n章"
  counter_references = ["section_counter"]
}
----

Output: "第一章", "第二章", "第三章"
====

[example]
====
Japanese financial numbering:

[source,lml]
----
instance Counter {
  id = "amount_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "japanese"
    sequence_type = "financial"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}
----

Output: "壱", "弐", "参"
====

[[annex-iso]]
[appendix]
== ISO DIR 2 auto-number items

The following table provides a comprehensive reference for auto-numbering elements according to ISO Directives Part 2:

.ISO Directives Part 2 auto-numbering elements
[cols="1,2,2,2"]
|===
|Element type |Numbering scheme |Example |ANDL implementation

|Clauses
|Arabic numerals, sequential throughout document
|1, 2, 3
|Counter bound to document scope

|Subclauses
|Hierarchical Arabic numerals
|1.1, 1.2, 2.1.1
|Counter with parent reference using hierarchical pattern

|Annexes
|Capital letters, sequential
|Annex A, Annex B
|Counter with alpha_upper format bound to document scope

|Appendices (in annexes)
|Arabic numerals, sequential within annex
|Appendix 1, Appendix 2
|Counter bound to annex scope

|Ordered lists (first level)
|Lowercase letters followed by closing parenthesis
|a), b), c)
|Counter with alpha_lower format and ")"-suffix pattern

|Ordered lists (second level)
|Lowercase Roman numerals in parentheses
|(i), (ii), (iii)
|Counter with roman_lower format and parentheses pattern

|Ordered lists (third level)
|Arabic numerals followed by period
|1., 2., 3.
|Counter with arabic format and "."-suffix pattern

|Figures
|Arabic numerals, sequential throughout document
|Figure 1, Figure 2
|Counter bound to document scope with "Figure %n" pattern

|Tables
|Arabic numerals, sequential throughout document
|Table 1, Table 2
|Counter bound to document scope with "Table %n" pattern

|Notes
|Arabic numerals, reset within each clause
|NOTE 1, NOTE 2
|Counter bound to clause scope with "NOTE %n" pattern

|Examples
|Arabic numerals, reset within each clause
|EXAMPLE 1, EXAMPLE 2
|Counter bound to clause scope with "EXAMPLE %n" pattern

|Formulae/equations
|Arabic numerals in parentheses, sequential throughout or by clause
|(1), (2), (3)
|Counter bound to document or clause scope with "(%n)" pattern
|===



NOTE: Anything that contains an "enumerable" item needs to have a counter. The counter needs to be linked to the parent counter if it is to inherit any pattern.

Some references need separate local and global patterns depend on where they are referenced from (such as lists, bound by the contexts).

Each structural element contains multiple counters depending on what it can count.

e.g.

* Document has a ClauseCounter, an AnnexCounter, a FigureCounter, a TableCounter.
** A Clause 1 has a SubClauseCounter.
** A Subclause 1 has a SubClauseCounter and also a ListCounter.
*** A ListCounter has ListItemCounter.
