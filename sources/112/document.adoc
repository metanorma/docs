= MN 112: Label Auto-assignment Definition Language (LADL) specification
:docnumber: 112
:edition: 1
:revdate: 2025-02-28
:copyright-year: 2025
:language: en
:title-main-en: Label Auto-assignment Definition Language (LADL) specification
:doctype: standard
:status: draft
:mn-document-class: ribose
:mn-output-extensions: xml,html,pdf,rxl
:local-cache-only:

[[introduction]]
== Introduction

This specification defines the Label Auto-assignment Definition Language (LADL), a
declarative modeling language for defining automatic label assignment requirements
across technical documentation and publishing systems.

NOTE: "LADL" is pronounced as "ladel".

Label auto-assignment is a critical component of structured documentation, enabling
consistent referencing and organization of content elements throughout a document.
The act is to automatically create correct Label objects that attach to the content
element. A Labeller object labels things with machine understandable labels, while
a LabelRenderer creates a string label from a Label object, depending on the usage
context (e.g., the same item can be labelled differently in different parts of the
content hierarchy).

LADL addresses these challenges by providing:

. A platform-independent numbering model that works consistently across rendering engines
. Built-in support for international numbering systems (including CJK)
. Hierarchical numbering with contextual awareness and scope binding
. Clear separation between semantic structure and presentation formatting
. Support for transformations to CSS, Word Styles, and XSLT counters
. String pattern interpolation for flexible label construction

LADL enables document architects and standards developers to define once and apply
everywhere, ensuring that numbering schemes work predictably across all outputs
while preserving both semantic structure and visual presentation requirements.

[[scope]]
== Scope

This document establishes requirements for defining auto-numbering schemes for:

* Ordered and unordered list items with multiple nesting levels
* Document structural elements (clauses, annexes, appendices)
* Figures, tables, examples, and notes
* Source code blocks and requirement statements
* CJK and other international numbering systems
* Hierarchical numbering relationships
* Advanced string pattern interpolation
* Counter scope binding based on document context

This specification defines the conceptual models for auto-numbering and their
transformation to implementation formats including CSS counters, Word Styles,
and XSLT counter variables.

[[terms-and-definitions]]
== Terms and definitions

=== counter

numeric or alphanumeric variable that tracks sequence position within a document context

=== sequence

ordered progression of values following defined rules for generation and formatting

=== numbering format

rules for representing a counter value in a particular alphanumeric system

[example]
====
Arabic numerals, Roman numerals, alphabetic characters.
====

=== numbering pattern

template combining counter values and literal characters to form complete labels

[example]
====
"Figure %n" is a pattern that generates labels like "Figure 1", "Figure 2", etc.
====

=== hierarchical numbering

numbering system where elements inherit context from parent elements

[example]
====
In a numbering system, "1.1.2" can represent the locality of "section 1,
subsection 1, clause 2".
====

=== counter scope

document boundary within which a counter operates, defining when the counter resets or continues

=== string interpolation

process of substituting variable placeholders in a pattern with actual values to construct a rendered label

=== label

machine-readable object that attaches to a content element for consistent and unambiguous reference of information in an information container

[example]
====
A label like "1.1.2" indicates it is the "first clause in document, first subclause, second subsubclause", while "Figure A.2" means it is the second image in Annex A.
====

=== labeller

component that assigns labels to content elements based on their position in the document structure and labeling context

=== label renderer

component that generates a human-readable label in string form from a label object, which may vary depending on the usage context

=== local reference

reference to content within the same context or document section, using labels to provide precise location information

=== global reference

reference to content across different contexts or document sections, using labels to provide unambiguous identification regardless of location

=== citation

formal reference to content using labels, enabling precise identification in both internal and external referencing systems

=== reference

general term for pointing to specific content elements using labels, enabling navigation, identification, and citation



[[requirements]]
== Requirements

=== Problem statement

Information management systems must produce consistent, predictable
auto-numbering across multiple output formats while:

* Preserving semantic relationships between numbered elements
* Adapting to different display requirements by format
* Supporting internationalization requirements
* Allowing for hierarchical numbering schemes
* Enabling flexible formatting of labels
* Managing counter scopes across document boundaries

=== Usage in Metanorma

Metanorma XML uses LADL to define label auto-assignment for elements that require
sequence tracking. These definitions are interpreted by end-format renderers to generate
appropriate labeling in the target format. The model must provide:

* Common patterns applicable across formats
* Format-specific transformation instructions
* Separation of semantic numbering (what something is) from presentation (how it appears)
* Support for complex numbering schemes required by standards organizations

[[principles]]
== Principles

=== Separation of concerns

LADL follows these fundamental design principles:

. *Separation of semantics and presentation*: Numbers represent both position in a sequence and
  visual labeling. These concerns must be separable for proper processing.

. *Context awareness*: Numbering systems must understand their position within document hierarchies.

. *Independence from format*: The model must define numbering in a way that can be consistently
  applied across HTML, PDF, Word, and other formats.

. *Transformation clarity*: Format-specific renderings must be clearly derivable from the base model.

. *Internationalization support*: Non-Latin numbering systems must be fully supported.

=== Model architecture

The LADL model architecture consists of:

* Core models defining counters, sequences, and formats
* Element-specific extensions for particular document components
* Transformation templates for output formats
* Hierarchical context management
* Scope binding framework
* Pattern interpolation system

[[core-models]]
== Core models

=== Language runtime and relationships

The LADL language runtime is responsible for interpreting and executing label
auto-assignment definitions. The runtime:

* Processes LADL definitions to create a label assignment model
* Maintains counter states and sequences throughout document processing
* Manages context hierarchies and inheritance relationships
* Executes label generation according to defined patterns
* Handles format-specific rendering requirements

The following diagrams illustrate the key relationships in the LADL model:

[source,ascii]
----
                  Counter Model Relationships
                  ==========================

+----------------+         +-------------------+
|    Counter     |         |  NumberSequence   |
|----------------|-------->|-------------------|
| id             |         | initial_value     |
| current_value  |         | increment         |
| sequence       |         | cycle_length      |
+----------------+         +-------------------+
        |
        |                  +-------------------+
        +----------------->| CharacterSequence |
                           |-------------------|
                           | type (alpha/roman)|
                           | case              |
                           | characters        |
                           +-------------------+

                   Scope and Element Binding
                   =======================

+----------------+         +----------------+
|    Counter     |<------->|     Scope      |
|----------------|         |----------------|
| id             |         | context        |
| sequence       |         | boundary       |
+----------------+         +----------------+
        |
        |                  +----------------+
        +----------------->|  ElementType   |
                           |----------------|
                           | name           |
                           | attributes     |
                           +----------------+

                 Hierarchical Counter Example
                 =========================

+-------------------+         +-------------------+
| Parent Counter    |         | Child Counter     |
|-------------------|<--------|-------------------|
| id: "section"     |         | id: "figure"      |
| sequence: 1,2,3.. |         | sequence: 1,2,3.. |
| scope: document   |         | scope: section    |
+-------------------+         +-------------------+
                                       |
                                       v
                              +-------------------+
                              | NumberingPattern  |
                              |-------------------|
                              | "%parent.%n"      |
                              | -> "1.1", "1.2"   |
                              +-------------------+

                 "Figure A.1" Construction
                 =======================

+-------------------+         +-------------------+
| Annex Counter     |         | Figure Counter    |
|-------------------|<--------|-------------------|
| id: "annex"       |         | id: "figure"      |
| sequence: A,B,C.. |         | sequence: 1,2,3.. |
| scope: document   |         | scope: annex      |
+-------------------+         +-------------------+
        |                               |
        v                               v
+-------------------+         +-------------------+
| Output: "A"       |         | Output: "1"       |
+-------------------+         +-------------------+
        |                               |
        |                               |
        v                               v
        +---------------+---------------+
                        |
                        v
                +-------------------+
                | Combined Pattern  |
                |-------------------|
                | "Figure %parent.%n"|
                | -> "Figure A.1"   |
                +-------------------+
----

=== Sequence

A sequence defines the progression of values for a counter.

There are two types of Sequence models that inherit from Sequence:

* CharacterSequence
* NumberSequence

[source,lml]
----
class Sequence {
  method value_for_order(order: Integer) {
    definition "Provide the value for a given order in the sequence"
  }

  method set_initial_value(order: Integer) {
    definition "Set the sequence to start at a specific value"
  }
}
----

[source,lml]
----
class NumberSequence < Sequence {
  attribute initial_value, Integer {
    definition "Starting value for the sequence"
    default: 1
  }
  attribute increment, Integer {
    definition "Value to increment by for each step"
    default: 1
  }
  attribute cycle_length, Integer {
    definition "Length after which sequence notation expands"
  }
  attribute base_sequence, Sequence {
    definition "Base sequence that this sequence builds upon"
  }
}
----

A LADL-compliant runtime should provide the following default
numbering sequences:

`DecimalNumberSequence`:: Standard decimal numbers (1, 2, 3...)
`RomanUpperNumberSequence`:: Uppercase Roman numerals (I, II, III...)
`RomanLowerNumberSequence`:: Lowercase Roman numerals (i, ii, iii...)
`AlphaUpperNumberSequence`:: Uppercase letters (A, B, C...)
`AlphaLowerNumberSequence`:: Lowercase letters (a, b, c...)
`CyrillicUpperCharacterSequence`:: Uppercase Cyrillic alphabet characters (А, Б, В, Г, Д, Е, Ж, З...)
`CyrillicLowerCharacterSequence`:: Lowercase Cyrillic alphabet characters (а, б, в, г, д, е, ж, з...)
`GreekUpperCharacterSequence`:: Uppercase Greek alphabet characters (Α, Β, Γ, Δ, Ε, Ζ, Η, Θ...)
`GreekLowerCharacterSequence`:: Lowercase Greek alphabet characters (α, β, γ, δ, ε, ζ, η, θ...)
`ChineseNumberSequence`:: Chinese numerals (一, 二, 三...)
`JapaneseNumberSequence`:: Japanese numerals (一, 二, 三...)
`KoreanNumberSequence`:: Korean numerals (일, 이, 삼...)
`ArabicNumberSequence`:: Arabic numerals in Arabic script (١, ٢, ٣...)

[example]
====
Instance definition of custom numeral sequence based on ArabicNumberSequence
that jumps every 3:

[source,lml]
----
instance ThreeIncrementArabicNumberSequence {
  base_sequence = ArabicNumberSequence
  initial_value = 1
  increment = 3
}
----

Produces a sequence of "1, 4, 7, 10, ...".
====

[example]
====
Instance definition of a custom numeral sequence based on Chinese numeral
sequence only gives even numbers:

[source,lml]
----
instance EvenChineseNumberSequence {
  base_sequence = ChineseNumberSequence
  initial_value = 2
  increment = 2
}
----

Produces a sequence of "二, 四, 六, 八, ...".
====


[source,lml]
----
class CharacterSequence < Sequence {
  attribute characters, String {
    definition "Strings that define a label for an ordered element in the sequence"
    cardinality 1..n
  }
  attribute expansion_rule, String {
    definition "Rule for expanding sequence after completion"
    values {
      value "repeat_label" {
        definition "Repeat the label character"
      }
      value "prepend_prefix" {
        definition "Add a new prefix character"
      }
      value "double_character" {
        definition "Double the character for expansion"
      }
      value "none" {
        definition "No expansion applied"
      }
      value "append_suffix" {
        definition "Append a suffix character after expansion"
      }
    }
  }
}
----

[example]
====
Certain ancient texts apply the numbering system of ["乾", "亨", "利", "貞"] as
book labels if there are 4 books in a series. The following definition applies
the expansion rule "prepend_prefix" to the sequence.

[source,lml]
----
instance YiJingCharacterSequence {
  characters = ["乾", "亨", "利", "貞"]
  expansion_rule = "prepend_prefix"
  expansion_prefix = ["乾", "坤", "巽", "震", "坎", "艮", "離", "兌"]
}
----

Produces a sequence of "乾, 亨, 利, 貞, 乾乾, 乾亨, 乾利, 乾貞, 亨乾, 亨亨, ...".
====

[example]
====
Greek literature uses the Greek alphabet and numerals for numbering, which
includes both letters and specific numeral characters for enumeration. The
following definition applies the expansion rule "double_character" to the
sequence.

[source,lml]
----
instance GreekCharacterSequence {
  characters = ["α", "β", "γ", "δ", "ε", "ζ", "η", "θ"]
  expansion_rule = "double_character"
}
----

Produces a sequence of "α, β, γ, δ, ε, ζ, η, θ, αα, ββ, γγ, δδ, ...".
====

=== Counter

The Counter model defines the fundamental mechanism for tracking sequence
position within a context.

[source,lml]
----
class Counter {
  attribute sequence, Sequence {
    definition "Sequence that defines the counter's possible values"
  }
  attribute context, Context {
    definition "Context to which this counter is bound"
  }
  attribute parent_counter, ref:(Counter) {
    definition "Parent counter to which this counter relies upon"
  }
}
----

=== Context

The Context class is responsible for defining the scope of counters within a
document. This includes both the element that establishes the scope and the type
of the scope.

----
class Context {
  attribute counters, ref:(Counter) {
    definition "All counters (of different types) that are bound to this context"
    collection true
  }

  attribute type, String {
    definition {
      Type of context element that defines this counter's scope.

      Values are free form, such as:

      * "document"
      * "section"
      * "container"
      * "clause"
      * "annex"
    }
  }

  method value_for_order_and_type(order: Integer, type: String) {
    definition "Provide the value for a given order in the sequence"
  }
}
----

[example]
====
Simple counter for tracking Notes:

[source,lml]
----
instance SectionContext {
  type = "section"
  counters = ["id:notes_counter"]
}

instance NotesCounter {
  id = "notes_counter"
  sequence = ArabicNumberSequence
}
----

The values would be:
----
> SectionContext.value_for_order_and_type(1, "note") => 1
> SectionContext.value_for_order_and_type(2, "note") => 2
> SectionContext.value_for_order_and_type(3, "note") => 3
----
====

[example]
====
Simple counter for tracking Figures:

[source,lml]
----
instance SectionContext {
  type = "section"
  counters = ["id:figure_counter"]
}

instance FigureCounter {
  id = "figure_counter"
  sequence = RomanUpperNumberSequence
}
----

The values would be:
----
> SectionContext.value_for_order_and_type(1, "figure") => I
> SectionContext.value_for_order_and_type(2, "figure") => II
> SectionContext.value_for_order_and_type(3, "figure") => III
----
====

=== Label pattern

The LabelPattern class defines how counter values are combined with fixed text
to create labels.

A string pattern with placeholders for counter values is used to generate the
visible label.

[source,lml]
----
class LabelPattern {
  attribute pattern, String {
    definition "Template string with placeholders for counter values"
  }
  attribute counter, Counter {
    definition "Counter driving the pattern"
  }
}
----

Interpolation patterns:

`%n`:: Counter value
`%parent`:: Parent counter value

[example]
====
Simple figure labeling pattern:

[source]
----
Figure %n
----

[source,lml]
----
instance FigureLabelPattern {
  pattern = "Figure %n"
}
----

Output: "Figure 1", "Figure 2", "Figure 3", etc.
====


=== Label renderer

The LabelRenderer class is responsible for transforming a label pattern into a
final label string.

[source,lml]
----
class LabelRenderer {
  attribute counter, Counter {
    definition "Counter driving the label"
  }
  attribute pattern, LabelPattern {
    definition "Pattern for generating the label"
  }

  method render_label(sequence: Integer) {
    definition "Render a label based on the counter and pattern"
  }
}
----

[example]
====
Rendering a label for a figure:

[source,lml]
----
instance FigureCounter {
  id = "figure_counter"
  sequence = ArabicNumberSequence
}

instance FigureLabelPattern {
  id = "figure_label_pattern"
  pattern = "Figure %n"
}

instance FigureLabelRenderer {
  counter = "figure_counter"
  pattern = "figure_label_pattern"
}
----

----
FigureLabelRenderer.render_label(3) => "Figure 3"
----
====

[example]
.Example with hierarchical numbering of clauses
====
Hierarchical numbering of clauses:

[source,lml]
----
instance ClauseNumberSequence < NumberSequence {
  initial_value = 1
  format = "arabic"
}

instance DocumentContext < Context {
  type = "document"
}

instance ClauseCounter < Counter {
  id = "clause_counter"
  sequence = ClauseNumberSequence
  scope = DocumentContext
}

instance ClauseLabelRenderer < LabelRenderer {
  counter = ClauseCounter
  pattern = instance ClauseLabelPattern < LabelPattern {
    pattern = "Clause %n"
  }
}
# ClauseLabelRenderer.render_label(1) => "Clause 1"
# ClauseLabelRenderer.render_label(3) => "Clause 3"

instance ClauseLabelRendererForSubclause < LabelRenderer {
  counter = ClauseCounter
  pattern = instance ClauseLabelPattern < LabelPattern {
    pattern = "%n"
  }
}
# ClauseLabelRendererForSubclause.render_label(1) => "1"
# ClauseLabelRendererForSubclause.render_label(3) => "3"

instance ClauseContext < Context {
  type = "clause"
}

instance SubClauseCounter < Counter {
  id = "subclause_counter"
  sequence = ClauseNumberSequence
  scope = ClauseContext
  parent_counter = ClauseLabelRendererForSubclause
}

instance SubClauseLabelRenderer < LabelRenderer {
  counter = SubClauseCounter
  pattern = instance SubClauseLabelPattern < LabelPattern {
    pattern = "%parent.%n"
  }
}
# SubClauseLabelRenderer.render_label(1) => "1.1"
# SubClauseLabelRenderer.render_label(3) => "1.3"
----
====

=== Presentation and semantics model

The Presentation and Semantics model separates meaning from display.

[source,lml]
----
class NumberedElement {
  attribute element_type, String {
    definition "Type of document element being numbered"
  }
  attribute semantic_info, SemanticInfo {
    definition "Semantic information about the numbered element"
  }
  attribute presentation_info, PresentationInfo {
    definition "Information about how the element should be presented"
  }
}

class SemanticInfo {
  attribute counters, Array {
    definition "Counters used to track this element"
    cardinality 1..n
  }
  attribute structure_level, Integer {
    definition "Level in document structure hierarchy"
  }
  attribute context_path, String {
    definition "XPath-like path to locate element in document structure"
  }
}

class PresentationInfo {
  attribute label_pattern, NumberingPattern {
    definition "Pattern for generating the visible label"
  }
  attribute format_overrides, Hash {
    definition "Format-specific overrides"
  }
  attribute style_properties, Hash {
    definition "CSS and other style properties"
  }
}
----

[example]
====
Separation of semantics and presentation for a figure:

[source,lml]
----
instance NumberedElement {
  element_type = "figure"
  semantic_info = instance SemanticInfo {
    counters = ["figure_counter"]
    structure_level = 1
    context_path = "/document/sections/section[id='section-3']/figure[1]"
  }
  presentation_info = instance PresentationInfo {
    label_pattern = instance NumberingPattern {
      pattern = "Figure %n —"
      counter_references = ["figure_counter"]
    }
  }
}
----

This separates the semantic information (it's the first figure in section 3) from the presentation (it should be labeled as "Figure 1 —").
====

[[referencing-model]]
== Referencing model

=== Purpose of labels

Labels serve as the foundation for consistent and unambiguous reference of information within documents. Their primary purpose is to enable:

* *Precise navigation* through hierarchical document structures
* *Unambiguous identification* of content elements regardless of their position
* *Citation systems* that work both internally and externally to the document

Labels provide machine-readable identifiers that can be rendered in human-readable form, allowing both automated systems and human readers to locate and reference specific content with precision.

=== Types of references

Labels support different types of references depending on their scope and usage:

==== Local references

Local references point to content within the same context, such as:

* References to figures within the same clause
* References to list items within the same list
* References to subclauses within the same parent clause

Local references may use simplified forms of labels that omit higher-level context information when that context is implied.

[example]
====
Within Clause 3, a reference to "Figure 2" might be sufficient rather than "Figure 3.2" because the clause context is understood.
====

==== Global references

Global references point to content across different contexts within the same document, such as:

* References to clauses from annexes
* References to figures from different sections
* References to tables from anywhere in the document

Global references require complete labels that include all necessary context information to ensure unambiguous identification.

[example]
====
A reference from Annex A to "Figure 3.2" clearly identifies the second figure in Clause 3, regardless of where the reference appears.
====

==== Citations

Citations are formal references that may extend beyond the current document, such as:

* References to external standards or publications
* References to specific elements within other documents
* References that may be used in bibliographic entries

Citations require standardized label formats that can be consistently interpreted across different documents and systems.

=== Reference resolution

The process of resolving references involves:

1. *Identification*: Determining the target element based on its label
2. *Context mapping*: Understanding the relationship between the reference context and the target context
3. *Rendering*: Presenting the reference in an appropriate format for the current context

The LADL model provides the foundation for this resolution process by ensuring that labels are:

* *Unique*: Each label uniquely identifies a specific content element
* *Structured*: Labels follow a consistent structure that reflects the document hierarchy
* *Context-aware*: Labels can be interpreted correctly regardless of where they appear

[[labeling-model]]
== Labeling model

=== General

The labeling model defines how elements in a document are assigned labels based on their context and position in both the document hierarchy and labeling hierarchy.

=== Core concepts

==== Distinction between content hierarchy and labeling context

The labeling model makes a clear distinction between:

* Content hierarchy: The structural organization of elements in the document (e.g., document containing clauses containing subclauses)
* Labeling context: The context used for determining how an element should be labeled, which may differ from its position in the content hierarchy

[example]
====
A list item within a deep subclause may be labeled according to a higher-level context, while still maintaining its position in the document structure.
====

==== Model definition

The core components of the labeling model are defined using LutaML:

[source,lml]
----
class Counter {
  definition {
    A counter tracks sequence position within a specific context.
  }

  attribute id, String {
    definition "Unique identifier for the counter"
  }
  attribute current_value, Integer {
    definition "Current value of the counter"
  }
  attribute sequence, Sequence {
    definition "Sequence that defines the counter's possible values"
  }
  attribute parent_counter, ref:(Counter) {
    definition "Parent counter to which this counter relates"
    cardinality 0..1
  }
  attribute context, Context {
    definition "Context to which this counter is bound"
  }
}

class Context {
  definition {
    Defines the scope and type of context for labeling elements.
  }

  attribute type, String {
    definition "Type of context element that defines this counter's scope"
    values { "document", "section", "container", "clause", "annex" }
  }
  attribute counters, ref:(Counter) {
    definition "All counters (of different types) that are bound to this context"
    cardinality 0..n
  }
}

class Label {
  definition {
    A label assigned to a content element, generated using a counter.
  }

  attribute content_element, String {
    definition "Reference to the content element being labeled"
  }
  attribute counter, Counter {
    definition "Counter used to generate this label"
  }
}

class LabelRenderer {
  definition {
    Renders a label according to a pattern, which may include references to parent labels.
  }

  attribute counter, Counter {
    definition "Counter driving the label generation"
  }
  attribute pattern, String {
    definition {
      Pattern for generating the label. Supports:
      - %n: output number from the counter
      - %p: parent's rendered label
      - %pn: output number from parent's labelrenderer
      - %local: localized label
    }
  }

  method render_label(sequence: Integer) {
    definition "Render a label based on the counter and pattern"
  }
}
----

=== Document hierarchy counters

The document structure contains multiple types of counters for different elements:

[source,lml]
----
class Document {
  definition {
    Root document containing various types of counters.
  }

  attribute clause_counter, Counter {
    definition "Counter for clauses in the main document"
  }
  attribute annex_counter, Counter {
    definition "Counter for annexes"
  }
  attribute figure_counter, Counter {
    definition "Counter for figures"
  }
  attribute table_counter, Counter {
    definition "Counter for tables"
  }
}

class Clause {
  definition {
    A clause in the document that contains its own counters.
  }

  attribute subclause_counter, Counter {
    definition "Counter for subclauses within this clause"
  }
}

class Subclause {
  definition {
    A subclause that contains both structural and list counters.
  }

  attribute subclause_counter, Counter {
    definition "Counter for further nested subclauses"
  }
  attribute list_counter, Counter {
    definition "Counter for lists within this subclause"
  }
}

class List {
  definition {
    A list containing items that need to be counted.
  }

  attribute list_item_counter, Counter {
    definition "Counter for items within this list"
  }
}
----

=== Example instances

The following examples demonstrate how the labeling model is used:

[source,lml]
----
instance Document {
  clause_counter = instance Counter {
    id = "main_clauses"
    sequence = instance NumberSequence {
      initial_value = 1
    }
  }

  figure_counter = instance Counter {
    id = "figures"
    sequence = instance NumberSequence {
      initial_value = 1
    }
  }
}

instance Clause {
  subclause_counter = instance Counter {
    id = "clause1_subclauses"
    parent_counter = ref:(Document.clause_counter)
    sequence = instance NumberSequence {
      initial_value = 1
    }
  }
}

instance LabelRenderer {
  counter = ref:(Clause.subclause_counter)
  pattern = "%p.%n"  // Produces labels like "1.1", "1.2", etc.
}
----

[[auto-numbered-items]]
== Auto-numbered items

=== List numbering

Lists are among the most commonly numbered elements in documents, with both ordered and unordered variants.

==== Ordered lists

Ordered lists use sequential counters with various numbering formats and nested hierarchies.

[source,lml]
----
class OrderedListNumbering {
  attribute counter, Counter {
    definition "Counter tracking list item position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for list item labels"
  }
  attribute level_formats, Array {
    definition "Formats to use at different nesting levels"
    cardinality 0..n
  }
}

class OrderedListLevelFormat {
  attribute level, Integer {
    definition "Nesting level (1 = top level)"
  }
  attribute format, SequenceFormat {
    definition "Numbering format for this level"
  }
  attribute pattern, String {
    definition "Label pattern for this level"
  }
}
----

[example]
====
Basic ordered list:

[source,lml]
----
instance OrderedListNumbering {
  counter = instance Counter {
    id = "ordered_list_items"
    sequence = instance NumberSequence {
      initial_value = 1
      format = "arabic"
    }
    scope = instance Context {
      context_element = "list"
      scope_type = "container"
    }
  }
  pattern = instance NumberingPattern {
    pattern = "%n. "
  }
}
----

Output: "1. ", "2. ", "3. "
====

[example]
====
Nested ordered list with different formats:

[source,lml]
----
instance OrderedListNumbering {
  level_formats = [
    instance OrderedListLevelFormat {
      level = 1
      format = "arabic"
      pattern = "%n. "
    },
    instance OrderedListLevelFormat {
      level = 2
      format = "alpha_lower"
      pattern = "%n) "
    },
    instance OrderedListLevelFormat {
      level = 3
      format = "roman_lower"
      pattern = "(%n) "
    }
  ]
}
----

Output for first level: "1. ", "2. ", "3. "
Output for second level: "a) ", "b) ", "c) "
Output for third level: "(i) ", "(ii) ", "(iii) "
====

==== Unordered lists

Unordered lists use non-sequential markers for visual distinction.

[source,lml]
----
class UnorderedListMarkers {
  attribute level_markers, Array {
    definition "Markers to use at different nesting levels"
    cardinality 1..n
  }
}

class UnorderedListLevelMarker {
  attribute level, Integer {
    definition "Nesting level (1 = top level)"
  }
  attribute marker, String {
    definition "Symbol to use for this level"
  }
}
----

[example]
====
Unordered list with custom markers:

[source,lml]
----
instance UnorderedListMarkers {
  level_markers = [
    instance UnorderedListLevelMarker {
      level = 1
      marker = "•"
    },
    instance UnorderedListLevelMarker {
      level = 2
      marker = "◦"
    },
    instance UnorderedListLevelMarker {
      level = 3
      marker = "▪"
    }
  ]
}
----

Output for first level: "• Item"
Output for second level: "◦ Item"
Output for third level: "▪ Item"
====

=== Clause numbering

Clauses form the primary structural elements of technical documents and use hierarchical numbering.

[source,lml]
----
class ClauseNumbering {
  attribute counter, Counter {
    definition "Counter tracking clause position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for clause labels"
  }
  attribute max_depth, Integer {
    definition "Maximum depth to display in numbering"
    default: 6
  }
}
----

[example]
====
Clause numbering with hierarchical structure:

[source,lml]
----
// Section counter
instance Counter {
  id = "section_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

// Subsection counter
instance Counter {
  id = "subsection_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "section"
    scope_type = "section"
  }
  parent_counter = "section_counter"
}

// Subsubsection counter
instance Counter {
  id = "subsubsection_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "subsection"
    scope_type = "section"
  }
  parent_counter = "subsection_counter"
}

// Patterns for each level
instance NumberingPattern {
  pattern = "%n"
  counter_references = ["section_counter"]
}

instance NumberingPattern {
  pattern = "%parent.%n"
  counter_references = ["subsection_counter", "section_counter"]
}

instance NumberingPattern {
  pattern = "%parent.%n"
  counter_references = ["subsubsection_counter", "subsection_counter"]
}
----

Output for section: "1", "2", "3"
Output for subsection: "1.1", "1.2", "2.1"
Output for subsubsection: "1.1.1", "1.1.2", "1.2.1"
====

=== Annex and appendix numbering

Annexes and appendices typically use different numbering schemes than the main document.

[source,lml]
----
class AnnexNumbering {
  attribute counter, Counter {
    definition "Counter for tracking annex position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for annex labels"
  }
  attribute prefix, String {
    definition "Text to prefix annex number with"
    default: "Annex "
  }
}
----

[example]
====
Annex numbering:

[source,lml]
----
instance Counter {
  id = "annex_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "alpha_upper"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "Annex %n"
  counter_references = ["annex_counter"]
}
----

Output: "Annex A", "Annex B", "Annex C"
====

[example]
====
Hierarchical annex with appendix:

[source,lml]
----
instance Counter {
  id = "annex_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "alpha_upper"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance Counter {
  id = "appendix_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "annex"
    scope_type = "section"
  }
  parent_counter = "annex_counter"
}

instance NumberingPattern {
  pattern = "Annex %n"
  counter_references = ["annex_counter"]
}

instance NumberingPattern {
  pattern = "Appendix %n"
  counter_references = ["appendix_counter"]
}
----

Output for annex: "Annex A", "Annex B"
Output for appendix within annex: "Appendix 1", "Appendix 2"
====

=== Figure numbering

Figures typically use a combination of sequential and hierarchical numbering.

[source,lml]
----
class FigureNumbering {
  attribute counter, Counter {
    definition "Counter for tracking figure position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for figure labels"
  }
  attribute caption_location, String {
    definition "Where to place the caption"
    values { "before", "after" }
    default: "after"
  }
}
----

[example]
====
Document-wide sequential figure numbering:

[source,lml]
----
instance Counter {
  id = "figure_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "Figure %n —"
  counter_references = ["figure_counter"]
}
----

Output: "Figure 1 —", "Figure 2 —", "Figure 3 —"
====

[example]
====
Hierarchical figure numbering by section:

[source,lml]
----
instance Counter {
  id = "figure_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "section"
    scope_type = "section"
  }
  parent_counter = "section_counter"
}

instance NumberingPattern {
  pattern = "Figure %parent.%n —"
  counter_references = ["figure_counter", "section_counter"]
}
----

Output: "Figure 1.1 —", "Figure 1.2 —", "Figure 2.1 —"
====

[example]
====
Figure in an annex:

[source,lml]
----
instance Counter {
  id = "figure_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "annex"
    scope_type = "section"
  }
  parent_counter = "annex_counter"
}

instance NumberingPattern {
  pattern = "Figure %parent.%n —"
  counter_references = ["figure_counter", "annex_counter"]
}
----

Output: "Figure A.1 —", "Figure A.2 —", "Figure B.1 —"
====

=== Table numbering

Tables use numbering schemes similar to figures but often with different presentation.

[source,lml]
----
class TableNumbering {
  attribute counter, Counter {
    definition "Counter for tracking table position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for table labels"
  }
  attribute caption_location, String {
    definition "Where to place the caption"
    values { "before", "after" }
    default: "before"
  }
}
----

[example]
====
Document-wide sequential table numbering:

[source,lml]
----
instance Counter {
  id = "table_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "Table %n —"
  counter_references = ["table_counter"]
}
----

Output: "Table 1 —", "Table 2 —", "Table 3 —"
====

=== Note numbering

Notes may appear throughout a document and are typically numbered within their context.

[source,lml]
----
class NoteNumbering {
  attribute counter, Counter {
    definition "Counter for tracking note position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for note labels"
  }
  attribute note_type, String {
    definition "Type of note"
    values { "note", "warning", "tip", "important", "caution" }
    default: "note"
  }
}
----

[example]
====
Notes numbered per clause:

[source,lml]
----
instance Counter {
  id = "note_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "clause"
    scope_type = "section"
  }
}

instance NumberingPattern {
  pattern = "NOTE %n:"
  counter_references = ["note_counter"]
}
----

Output within a clause: "NOTE 1:", "NOTE 2:", "NOTE 3:"
When a new clause begins, numbering restarts.
====

=== Example numbering

Examples often follow similar numbering patterns to notes.

[source,lml]
----
class ExampleNumbering {
  attribute counter, Counter {
    definition "Counter for tracking example position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for example labels"
  }
}
----

[example]
====
Examples numbered per document:

[source,lml]
----
instance Counter {
  id = "example_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "EXAMPLE %n:"
  counter_references = ["example_counter"]
}
----

Output: "EXAMPLE 1:", "EXAMPLE 2:", "EXAMPLE 3:"
====

=== Source code numbering

Source code blocks may be numbered for reference.

[source,lml]
----
class SourceCodeNumbering {
  attribute counter, Counter {
    definition "Counter for tracking source code block position"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for source code labels"
  }
  attribute caption_location, String {
    definition "Where to place the caption"
    values { "before", "after" }
    default: "before"
  }
  attribute line_numbers, Boolean {
    definition "Whether to include line numbers"
    default: false
  }
}
----

[example]
====
Source code blocks with captions:

[source,lml]
----
instance Counter {
  id = "sourcecode_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "Listing %n —"
  counter_references = ["sourcecode_counter"]
}
----

Output: "Listing 1 — Example function", "Listing 2 — Another function"
====

=== Requirement numbering

Requirements often need special numbering for traceability.

[source,lml]
----
class RequirementNumbering {
  attribute counter, Counter {
    definition "Counter for tracking requirement position"
  }
  attribute prefix, String {
    definition "Prefix for requirement ID"
    default: "REQ-"
  }
  attribute pattern, NumberingPattern {
    definition "Pattern for requirement labels"
  }
}
----

[example]
====
Hierarchical requirement numbering:

[source,lml]
----
instance Counter {
  id = "requirement_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    context_element = "section"
    scope_type = "section"
  }
  parent_counter = "section_counter"
}

instance NumberingPattern {
  pattern = "REQ-%parent.%n"
  counter_references = ["requirement_counter", "section_counter"]
}
----

Output: "REQ-1.1", "REQ-1.2", "REQ-2.1"
====

=== CJK numbering support

The CJK numbering model provides support for Chinese, Japanese, and Korean numbering systems.

[source,lml]
----
class CJKNumbering {
  attribute language, String {
    values { "zh", "ja", "ko" }
    definition "Language code determining the numbering system"
  }
  attribute format_type, String {
    values { "financial", "formal", "informal", "simplified" }
    definition "Style of CJK numerals to use"
    default: "formal"
  }
  attribute counter_reference, String {
    definition "Reference to the base counter to convert"
  }
}
----

[example]
====
Chinese formal numbering:

[source,lml]
----
instance Counter {
  id = "section_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "chinese"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}

instance NumberingPattern {
  pattern = "第%n章"
  counter_references = ["section_counter"]
}
----

Output: "第一章", "第二章", "第三章"
====

[example]
====
Japanese financial numbering:

[source,lml]
----
instance Counter {
  id = "amount_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "japanese"
    sequence_type = "financial"
  }
  scope = instance Context {
    context_element = "document"
    scope_type = "document"
  }
}
----

Output: "壱", "弐", "参"
====

[[annex-counter-hierarchy]]
[appendix]
== Counter hierarchy diagram

The following diagram illustrates the relationships between different components in the labeling model:

image::counter-hierarchy-document-full.svg[Counter hierarchy diagram,800]

=== Diagram explanation

The diagram illustrates the critical distinction between content hierarchy and labeling context in the LADL model:

* *Double dashed lines* represent content hierarchy (e.g., document containing clauses containing subclauses)
* *Unlabeled directional lines* represent ownership (e.g., document owning a ClauseCounter and an AnnexCounter)
* *Lines labeled "Parent"* show counter inheritance relationships between parent and child counters
* *Lines labeled "Labels"* show where a Counter/Labeller assigns a Label to a content element

This diagram demonstrates how:

* The LabelingContext is different from the actual content hierarchy
* Elements may be labeled according to a higher context even if they belong to a lower document hierarchy
* Some elements are labeled according to context belonging to the document hierarchy
* In a LabelRenderer, the pattern used can depend on:
  ** `%n` - the output number from the counter
  ** `%p` - the parent's rendered label
  ** `%pn` - the output number from the parent's labelrenderer
  ** `%local` - the localized label
* Some labelrenderers need to obtain the rendered label from the parent's labelrenderer

=== Instance model

The following instance model definitions illustrate the relationships shown in the diagram:

[source,lml]
----
// Document and its counters
instance Document {
  // Document owns multiple counters for different element types
  clause_counter = instance ClauseCounter {
    id = "clause_counter"
    sequence = instance NumberSequence {
      initial_value = 1
      format = "arabic"
    }
  }

  annex_counter = instance AnnexCounter {
    id = "annex_counter"
    sequence = instance NumberSequence {
      initial_value = 1
      format = "alpha_upper"
    }
  }

  figure_counter = instance FigureCounter {
    id = "figure_counter"
    sequence = instance NumberSequence {
      initial_value = 1
      format = "arabic"
    }
  }

  table_counter = instance TableCounter {
    id = "table_counter"
    sequence = instance NumberSequence {
      initial_value = 1
      format = "arabic"
    }
  }
}

// Clause and its counter
instance Clause {
  id = "clause_1"

  // Clause has a subclause counter
  subclause_counter = instance SubClauseCounter {
    id = "subclause_counter"
    parent_counter = ref:(Document.clause_counter)
    sequence = instance NumberSequence {
      initial_value = 1
      format = "arabic"
    }
  }
}

// Subclause and its counters
instance Subclause {
  id = "subclause_1"

  // Subclause has both a subclause counter and a list counter
  subclause_counter = instance SubClauseCounter {
    id = "subsubclause_counter"
    parent_counter = ref:(Clause.subclause_counter)
    sequence = instance NumberSequence {
      initial_value = 1
      format = "arabic"
    }
  }

  list_counter = instance ListCounter {
    id = "list_counter"
    sequence = instance NumberSequence {
      initial_value = 1
      format = "alpha_lower"
    }
  }
}

// List and its counter
instance List {
  id = "list_1"

  // List has a list item counter
  list_item_counter = instance ListItemCounter {
    id = "list_item_counter"
    parent_counter = ref:(Subclause.list_counter)
    sequence = instance NumberSequence {
      initial_value = 1
      format = "arabic"
    }
  }
}

// Label renderers for different elements
instance ClauseLabelRenderer {
  counter = ref:(Document.clause_counter)
  pattern = "%n"  // Renders as "1", "2", etc.
}

instance SubclauseLabelRenderer {
  counter = ref:(Clause.subclause_counter)
  pattern = "%p.%n"  // Renders as "1.1", "1.2", etc.
}

instance ListLabelRenderer {
  counter = ref:(Subclause.list_counter)
  pattern = "%p.%n)"  // Renders as "1.1.a)", "1.1.b)", etc.
}

instance ListItemLabelRenderer {
  counter = ref:(List.list_item_counter)
  pattern = "%p.%n"  // Renders as "1.1.a.1", "1.1.a.2", etc.
}
----

This structure enables:

* Separation between content hierarchy and labeling contexts
* Flexible label generation through parent-child counter relationships
* Context-aware label rendering based on usage location
* Support for different label formats in different contexts

[[annex-iso]]
[appendix]
== ISO DIR 2 label definitions

The following section provides LADL instance definitions for ISO Directives Part 2 elements:

[source,lml]
----
// Document-level context
instance DocumentContext {
  type = "document"
}

// Clause labeling
instance ClauseCounter {
  id = "clause_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = DocumentContext
}

instance ClauseLabelRenderer {
  counter = ClauseCounter
  pattern = "%n"
}

// Subclause labeling
instance SubclauseCounter {
  id = "subclause_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  parent_counter = ClauseCounter
  scope = instance Context {
    type = "clause"
  }
}

instance SubclauseLabelRenderer {
  counter = SubclauseCounter
  pattern = "%p.%n"
}

// Annex labeling
instance AnnexCounter {
  id = "annex_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "alpha_upper"
  }
  scope = DocumentContext
}

instance AnnexLabelRenderer {
  counter = AnnexCounter
  pattern = "Annex %n"
}

// Figure labeling
instance FigureCounter {
  id = "figure_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = DocumentContext
}

instance FigureLabelRenderer {
  counter = FigureCounter
  pattern = "Figure %n"
}

// Table labeling
instance TableCounter {
  id = "table_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = DocumentContext
}

instance TableLabelRenderer {
  counter = TableCounter
  pattern = "Table %n"
}

// Example labeling
instance ExampleCounter {
  id = "example_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    type = "clause"
  }
}

instance ExampleLabelRenderer {
  counter = ExampleCounter
  pattern = "EXAMPLE %n"
}

// Note labeling
instance NoteCounter {
  id = "note_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    type = "clause"
  }
}

instance NoteLabelRenderer {
  counter = NoteCounter
  pattern = "NOTE %n"
}

// Equation labeling
instance EquationCounter {
  id = "equation_counter"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = DocumentContext
}

instance EquationLabelRenderer {
  counter = EquationCounter
  pattern = "(%n)"
}

// List labeling - Level 1
instance ListCounter1 {
  id = "list_counter_1"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "alpha_lower"
  }
  scope = instance Context {
    type = "list"
  }
}

instance ListLabelRenderer1 {
  counter = ListCounter1
  pattern = "%n)"
}

// List labeling - Level 2
instance ListCounter2 {
  id = "list_counter_2"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "roman_lower"
  }
  scope = instance Context {
    type = "list"
  }
}

instance ListLabelRenderer2 {
  counter = ListCounter2
  pattern = "(%n)"
}

// List labeling - Level 3
instance ListCounter3 {
  id = "list_counter_3"
  sequence = instance NumberSequence {
    initial_value = 1
    format = "arabic"
  }
  scope = instance Context {
    type = "list"
  }
}

instance ListLabelRenderer3 {
  counter = ListCounter3
  pattern = "%n."
}
----

These instance definitions provide the complete labeling configuration for ISO DIR 2 elements, including:

* Hierarchical clause and subclause labeling
* Sequential annex labeling with letter-based counters
* Document-wide figure and table labeling
* Context-bound note and example labeling
* Multi-level list labeling with different formats per level
* Equation labeling with parenthetical format



NOTE: Anything that contains an "enumerable" item needs to have a counter. The counter needs to be linked to the parent counter if it is to inherit any pattern.

Some references need separate local and global patterns depend on where they are referenced from (such as lists, bound by the contexts).

Each structural element contains multiple counters depending on what it can count.

e.g.

* Document has a ClauseCounter, an AnnexCounter, a FigureCounter, a TableCounter.
** A Clause 1 has a SubClauseCounter.
** A Subclause 1 has a SubClauseCounter and also a ListCounter.
*** A ListCounter has ListItemCounter.
